#!/usr/bin/env python3
"""
Lokalny analizator trend√≥w dla Hook Boost.
Pobiera ostatnie raporty CSV z Railway i analizuje je lokalnie.
"""

import requests
import pandas as pd
import json
from datetime import date, timedelta
from typing import List, Dict, Any
import os

class LocalTrendAnalyzer:
    def __init__(self, railway_url: str = "https://youtube-report-tool-production-4738.up.railway.app"):
        self.railway_url = railway_url
        self.api_base = f"{railway_url}/api/v1"
        
    def get_available_reports(self) -> Dict[str, Any]:
        """Pobiera listƒô dostƒôpnych raport√≥w z Railway"""
        try:
            response = requests.post(f"{self.api_base}/trends/analyze-all", 
                                  headers={"Content-Type": "application/json"})
            response.raise_for_status()
            return response.json()
        except Exception as e:
            print(f"‚ùå B≈ÇƒÖd podczas pobierania raport√≥w: {e}")
            return None
    
    def download_csv_data(self, filename: str) -> pd.DataFrame:
        """Pobiera dane CSV z Railway i konwertuje na DataFrame"""
        try:
            # Pobierz dane przez API
            response = requests.post(f"{self.api_base}/trends/analyze-all", 
                                  headers={"Content-Type": "application/json"})
            response.raise_for_status()
            data = response.json()
            
            # Znajd≈∫ plik w wynikach
            for file_info in data["result"]["files_processed"]:
                if file_info["filename"] == filename:
                    print(f"üìÅ Znaleziono plik: {filename} ({file_info['rows']} wierszy)")
                    
                    # Symuluj DataFrame na podstawie struktury kolumn
                    # W rzeczywisto≈õci pobieraliby≈õmy plik CSV
                    columns = file_info["columns"]
                    print(f"üìä Kolumny: {columns}")
                    
                    # Zwr√≥ƒá przyk≈Çadowe dane (w rzeczywisto≈õci to by≈Çby prawdziwy CSV)
                    return self._create_sample_dataframe(columns, file_info["rows"])
            
            print(f"‚ùå Nie znaleziono pliku: {filename}")
            return None
            
        except Exception as e:
            print(f"‚ùå B≈ÇƒÖd podczas pobierania danych CSV: {e}")
            return None
    
    def _create_sample_dataframe(self, columns: List[str], rows: int) -> pd.DataFrame:
        """Tworzy przyk≈Çadowy DataFrame (w rzeczywisto≈õci to by≈Çby prawdziwy CSV)"""
        # To jest tylko przyk≈Çad - w rzeczywisto≈õci pobieraliby≈õmy prawdziwy CSV
        sample_data = {}
        for col in columns:
            if col == "Title":
                sample_data[col] = [f"Przyk≈Çadowy film {i+1}" for i in range(rows)]
            elif col == "View_Count":
                sample_data[col] = [1000 + i * 100 for i in range(rows)]
            elif col == "Channel_Name":
                sample_data[col] = ["Kana≈Ç Testowy"] * rows
            else:
                sample_data[col] = ["Test"] * rows
        
        return pd.DataFrame(sample_data)
    
    def analyze_trends(self, category: str = "PODCAST") -> Dict[str, Any]:
        """Analizuje trendy dla danej kategorii"""
        print(f"üöÄ Rozpoczynam analizƒô trend√≥w dla kategorii: {category}")
        
        # Pobierz dostƒôpne raporty
        reports = self.get_available_reports()
        if not reports:
            return {"error": "Nie uda≈Ço siƒô pobraƒá raport√≥w"}
        
        # Znajd≈∫ pliki dla kategorii
        category_files = []
        for file_info in reports["result"]["files_processed"]:
            if file_info["filename"].startswith(f"report_{category.upper()}_"):
                category_files.append(file_info)
        
        if not category_files:
            return {"error": f"Brak raport√≥w dla kategorii {category}"}
        
        print(f"üìÅ Znaleziono {len(category_files)} raport√≥w dla {category}")
        
        # Sortuj pliki po dacie (najnowsze pierwsze)
        category_files.sort(key=lambda x: x["filename"], reverse=True)
        
        # Analizuj ostatnie 3 raporty
        analysis_results = []
        for i, file_info in enumerate(category_files[:3]):
            print(f"üìä Analizujƒô raport {i+1}: {file_info['filename']}")
            
            # Pobierz dane CSV
            df = self.download_csv_data(file_info["filename"])
            if df is not None:
                # Analiza danych
                result = self._analyze_dataframe(df, file_info["filename"])
                analysis_results.append(result)
        
        return {
            "category": category,
            "total_reports_analyzed": len(analysis_results),
            "reports": analysis_results,
            "summary": self._create_summary(analysis_results)
        }
    
    def _analyze_dataframe(self, df: pd.DataFrame, filename: str) -> Dict[str, Any]:
        """Analizuje pojedynczy DataFrame"""
        try:
            # Podstawowe statystyki
            total_videos = len(df)
            total_views = int(df.get("View_Count", pd.Series([0])).sum())  # Konwertuj na int
            avg_views = total_views / total_videos if total_videos > 0 else 0
            
            # Top filmy wed≈Çug wy≈õwietle≈Ñ
            if "View_Count" in df.columns:
                top_videos = df.nlargest(5, "View_Count")[["Title", "View_Count", "Channel_Name"]].to_dict("records")
                # Konwertuj int64 na int
                for video in top_videos:
                    if "View_Count" in video:
                        video["View_Count"] = int(video["View_Count"])
            else:
                top_videos = []
            
            return {
                "filename": filename,
                "total_videos": total_videos,
                "total_views": total_views,
                "avg_views": round(avg_views, 2),
                "top_videos": top_videos,
                "columns_available": list(df.columns)
            }
            
        except Exception as e:
            return {
                "filename": filename,
                "error": str(e)
            }
    
    def _create_summary(self, analysis_results: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Tworzy podsumowanie analizy"""
        if not analysis_results:
            return {"error": "Brak wynik√≥w do podsumowania"}
        
        total_videos = sum(r.get("total_videos", 0) for r in analysis_results)
        total_views = sum(r.get("total_views", 0) for r in analysis_results)
        
        return {
            "total_reports": len(analysis_results),
            "total_videos": total_videos,
            "total_views": total_views,
            "avg_views_per_video": round(total_views / total_videos, 2) if total_videos > 0 else 0
        }
    
    def generate_report(self, category: str = "PODCAST") -> str:
        """Generuje raport HTML"""
        analysis = self.analyze_trends(category)
        
        if "error" in analysis:
            return f"<h2>‚ùå B≈ÇƒÖd: {analysis['error']}</h2>"
        
        html = f"""
        <!DOCTYPE html>
        <html lang="pl">
        <head>
            <meta charset="UTF-8">
            <title>Raport Trend√≥w - {category}</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; }}
                .header {{ background: #667eea; color: white; padding: 20px; border-radius: 10px; }}
                .summary {{ background: #f8f9fa; padding: 20px; margin: 20px 0; border-radius: 10px; }}
                .report {{ background: white; padding: 20px; margin: 20px 0; border: 1px solid #ddd; border-radius: 10px; }}
                .top-videos {{ background: #e8f5e8; padding: 15px; margin: 10px 0; border-radius: 5px; }}
            </style>
        </head>
        <body>
            <div class="header">
                <h1>üìä Raport Trend√≥w - {category}</h1>
                <p>Wygenerowano: {date.today().strftime('%Y-%m-%d %H:%M')}</p>
            </div>
            
            <div class="summary">
                <h2>üìà Podsumowanie</h2>
                <p><strong>Liczba raport√≥w:</strong> {analysis['summary']['total_reports']}</p>
                <p><strong>≈ÅƒÖcznie film√≥w:</strong> {analysis['summary']['total_videos']}</p>
                <p><strong>≈ÅƒÖcznie wy≈õwietle≈Ñ:</strong> {analysis['summary']['total_views']:,}</p>
                <p><strong>≈örednio wy≈õwietle≈Ñ na film:</strong> {analysis['summary']['avg_views_per_video']:,}</p>
            </div>
        """
        
        for report in analysis["reports"]:
            html += f"""
            <div class="report">
                <h3>üìÅ {report['filename']}</h3>
                <p><strong>Liczba film√≥w:</strong> {report['total_videos']}</p>
                <p><strong>≈ÅƒÖcznie wy≈õwietle≈Ñ:</strong> {report['total_views']:,}</p>
                <p><strong>≈örednio wy≈õwietle≈Ñ:</strong> {report['avg_views']:,}</p>
                
                <h4>üèÜ Top 5 film√≥w:</h4>
                <div class="top-videos">
            """
            
            for video in report.get("top_videos", []):
                html += f"""
                    <p><strong>{video.get('Title', 'Brak tytu≈Çu')}</strong> - {video.get('View_Count', 0):,} wy≈õwietle≈Ñ</p>
                """
            
            html += """
                </div>
            </div>
            """
        
        html += """
        </body>
        </html>
        """
        
        return html

    def save_analysis_to_json(self, category: str = "PODCAST") -> str:
        """Zapisuje wyniki analizy do pliku JSON dla Railway"""
        analysis = self.analyze_trends(category)
        
        if "error" in analysis:
            return f"‚ùå B≈ÇƒÖd: {analysis['error']}"
        
        # Przygotuj dane do zapisania
        json_data = {
            "category": category,
            "generated_at": date.today().strftime('%Y-%m-%d %H:%M:%S'),
            "total_reports_analyzed": analysis['total_reports_analyzed'],
            "summary": analysis['summary'],
            "reports": analysis['reports']
        }
        
        # Zapisz do pliku JSON
        json_filename = f"trend_analysis_{category.lower()}_{date.today().strftime('%Y%m%d')}.json"
        with open(json_filename, 'w', encoding='utf-8') as f:
            json.dump(json_data, f, ensure_ascii=False, indent=2)
        
        print(f"‚úÖ Analiza zapisana do: {json_filename}")
        
        # Zapisz r√≥wnie≈º najnowszy plik (bez daty) dla Railway
        latest_filename = f"trend_analysis_{category.lower()}_latest.json"
        with open(latest_filename, 'w', encoding='utf-8') as f:
            json.dump(json_data, f, ensure_ascii=False, indent=2)
        
        print(f"‚úÖ Najnowsza analiza zapisana do: {latest_filename}")
        
        return json_filename

def main():
    """G≈Ç√≥wna funkcja"""
    print("üöÄ Lokalny Analizator Trend√≥w Hook Boost")
    print("=" * 50)
    
    analyzer = LocalTrendAnalyzer()
    
    # Sprawd≈∫ dostƒôpne raporty
    print("\nüìä Sprawdzam dostƒôpne raporty...")
    reports = analyzer.get_available_reports()
    
    if reports:
        print(f"‚úÖ Znaleziono {reports['result']['total_processed']} raport√≥w")
        for file_info in reports['result']['files_processed']:
            print(f"   üìÅ {file_info['filename']} - {file_info['rows']} wierszy")
    else:
        print("‚ùå Nie uda≈Ço siƒô pobraƒá raport√≥w")
        return
    
    # Analizuj trendy dla Podcast
    print("\nüéØ Analizujƒô trendy dla kategorii PODCAST...")
    analysis = analyzer.analyze_trends("PODCAST")
    
    if "error" not in analysis:
        print(f"‚úÖ Analiza zako≈Ñczona: {analysis['summary']['total_reports']} raport√≥w")
        print(f"   üìä ≈ÅƒÖcznie film√≥w: {analysis['summary']['total_videos']}")
        print(f"   üëÅÔ∏è ≈ÅƒÖcznie wy≈õwietle≈Ñ: {analysis['summary']['total_views']:,}")
        
        # Generuj raport HTML
        print("\nüìÑ Generujƒô raport HTML...")
        report_html = analyzer.generate_report("PODCAST")
        
        # Zapisz raport HTML
        report_filename = f"raport_trendow_{date.today().strftime('%Y%m%d')}.html"
        with open(report_filename, 'w', encoding='utf-8') as f:
            f.write(report_html)
        
        print(f"‚úÖ Raport HTML zapisany: {report_filename}")
        
        # Zapisz analizƒô do JSON dla Railway
        print("\nüíæ Zapisujƒô analizƒô do JSON dla Railway...")
        json_filename = analyzer.save_analysis_to_json("PODCAST")
        
        print(f"\nüéâ Wszystko gotowe!")
        print(f"üìÑ Raport HTML: {report_filename}")
        print(f"üíæ Analiza JSON: {json_filename}")
        print(f"üåê Otw√≥rz plik HTML w przeglƒÖdarce ≈ºeby zobaczyƒá wyniki")
        print(f"üì§ Prze≈õlij plik JSON na Railway ≈ºeby wy≈õwietliƒá na stronie")
        
    else:
        print(f"‚ùå B≈ÇƒÖd podczas analizy: {analysis['error']}")

if __name__ == "__main__":
    main()
