from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.cron import CronTrigger
import logging
from datetime import datetime
from typing import Dict, List
from ..config import settings
from ..youtube import YouTubeClient
from ..storage import CSVGenerator
from ..storage.state_manager import StateManager
from pathlib import Path
import pandas as pd
import pytz

logger = logging.getLogger(__name__)


class TaskScheduler:
    """Scheduler zada≈Ñ z APScheduler"""
    
    def __init__(self):
        # U≈ºyj polskiej strefy czasowej
        timezone = pytz.timezone(settings.timezone)
        self.scheduler = AsyncIOScheduler(timezone=timezone)
        self.state_manager = StateManager()  # ZarzƒÖdza trwa≈Çymi danymi
        self.youtube_client = YouTubeClient(settings.youtube_api_key, self.state_manager)
        self.csv_generator = CSVGenerator()
    
    def start(self) -> bool:
        """Uruchamia scheduler"""
        try:
            if self.scheduler.running:
                print("‚ÑπÔ∏è Scheduler ju≈º uruchomiony")
                logger.info("Scheduler ju≈º uruchomiony")
                return True
            
            # Sprawd≈∫ czy zadania ju≈º istniejƒÖ
            existing_jobs = self.scheduler.get_jobs()
            if existing_jobs:
                print(f"‚ö†Ô∏è Znaleziono {len(existing_jobs)} istniejƒÖcych zada≈Ñ - usuwam")
                for job in existing_jobs:
                    job.remove()
            
            # Dodaj zadania
            self.scheduler.add_job(
                self.daily_report_task,
                'cron',
                hour=settings.scheduler_hour,
                minute=settings.scheduler_minute,
                id='daily_report',
                name='Codzienny raport o 1:00'
            )
            
            self.scheduler.add_job(
                self.daily_ranking_analysis_task,
                'cron',
                hour=settings.scheduler_hour,
                minute=settings.scheduler_minute + 30,
                id='daily_ranking_analysis',
                name='Codzienna analiza rankingowa o 1:30'
            )
            
            # Uruchom scheduler
            self.scheduler.start()
            
            # Sprawd≈∫ czy scheduler siƒô uruchomi≈Ç
            if not self.scheduler.running:
                print("‚ùå Scheduler nie uruchomi≈Ç siƒô")
                logger.error("Scheduler nie uruchomi≈Ç siƒô")
                return False
            
            # Sprawd≈∫ czy zadania sƒÖ zaplanowane
            jobs = self.scheduler.get_jobs()
            print(f"‚úÖ Scheduler uruchomiony pomy≈õlnie!")
            print(f"üìÖ Zaplanowane zadania: {len(jobs)}")
            for job in jobs:
                print(f"   - {job.name}: {job.next_run_time}")
            
            timezone = pytz.timezone(settings.timezone)
            print(f"‚úÖ Scheduler uruchomiony - raporty codziennie o {settings.scheduler_hour}:{str(settings.scheduler_minute).zfill(2)} {timezone}")
            logger.info(f"Scheduler uruchomiony - raporty codziennie o {settings.scheduler_hour}:{str(settings.scheduler_minute).zfill(2)} {timezone}")
            
        except Exception as e:
            print(f"‚ùå B≈ÇƒÖd podczas uruchamiania schedulera: {e}")
            logger.error(f"B≈ÇƒÖd podczas uruchamiania schedulera: {e}")
            import traceback
            traceback.print_exc()
            # Nie rzucaj b≈Çƒôdu - pozw√≥l aplikacji siƒô uruchomiƒá
            return False
        
        return True
    
    def stop(self):
        """Zatrzymuje scheduler"""
        if self.scheduler.running:
            self.scheduler.shutdown()
            logger.info("Scheduler zatrzymany")
    
    async def daily_report_task(self):
        """Codzienne zadanie generowania raport√≥w"""
        try:
            logger.info("Rozpoczƒôcie codziennego zadania raportowania")
            print("üîÑ Rozpoczynam codzienne zadanie raportowania...")
            
            # Reset quota (tylko raz dziennie)
            self.state_manager.reset_quota()
            print("‚úÖ Quota zresetowana")
            
            # Pobierz dane ze wszystkich kana≈Ç√≥w
            all_videos = {}
            total_quota_before = self.youtube_client.get_quota_usage()['used']
            print(f"üìä Quota przed raportowaniem: {total_quota_before}")
            
            for category, channels in self.state_manager.get_channels().items():
                category_videos = []
                
                for channel in channels:
                    try:
                        print(f"üì∫ Pobieram dane z kana≈Çu: {channel['title']}")
                        videos = await self.youtube_client.get_channel_videos(
                            channel['id'], 
                            settings.days_back
                        )
                        
                        # Dodaj informacje o kanale do ka≈ºdego filmu
                        for video in videos:
                            video['channel_title'] = channel['title']
                            video['channel_id'] = channel['id']
                        
                        category_videos.extend(videos)
                        print(f"‚úÖ Pobrano {len(videos)} film√≥w z kana≈Çu {channel['title']}")
                        logger.info(f"Pobrano {len(videos)} film√≥w z kana≈Çu {channel['title']}")
                        
                    except Exception as e:
                        print(f"‚ùå B≈ÇƒÖd podczas pobierania film√≥w z kana≈Çu {channel['title']}: {e}")
                        logger.error(f"B≈ÇƒÖd podczas pobierania film√≥w z kana≈Çu {channel['title']}: {e}")
                
                if category_videos:
                    all_videos[category] = category_videos
            
            # Generuj raporty CSV
            if all_videos:
                total_videos = sum(len(videos) for videos in all_videos.values())
                print(f"üìä ≈ÅƒÖcznie pobrano {total_videos} film√≥w")
                
                # Raport dla ka≈ºdej kategorii
                for category, videos in all_videos.items():
                    try:
                        csv_path = self.csv_generator.generate_csv(videos, category)
                        print(f"‚úÖ Wygenerowano raport dla kategorii {category}: {csv_path}")
                        logger.info(f"Wygenerowano raport dla kategorii {category}: {csv_path}")
                    except Exception as e:
                        print(f"‚ùå B≈ÇƒÖd podczas generowania raportu dla kategorii {category}: {e}")
                        logger.error(f"B≈ÇƒÖd podczas generowania raportu dla kategorii {category}: {e}")
                
                # Sprawd≈∫ zu≈ºycie quota po raportowaniu
                total_quota_after = self.youtube_client.get_quota_usage()['used']
                quota_used = total_quota_after - total_quota_before
                print(f"üìä Quota po raportowaniu: {total_quota_after}")
                print(f"üìä Zu≈ºyto quota: {quota_used} jednostek")
                
                # Zapisz aktualne zu≈ºycie quota po wygenerowaniu raport√≥w
                try:
                    current_quota = self.youtube_client.get_quota_usage()
                    self.state_manager.persist_quota(current_quota['used'])
                    print(f"‚úÖ Zapisano quota: {current_quota['used']}")
                    logger.info(f"Zapisano quota po wygenerowaniu raport√≥w: {current_quota['used']}")
                except Exception as e:
                    print(f"‚ùå B≈ÇƒÖd podczas zapisywania quota: {e}")
                    logger.error(f"B≈ÇƒÖd podczas zapisywania quota: {e}")
            else:
                print("‚ö†Ô∏è Brak film√≥w do raportowania")
            
            # Log quota usage
            quota_state = self.state_manager.get_quota_state()
            print(f"üìä Stan quota: {quota_state['used']}/10000 ({quota_state['used']/100:.1f}%)")
            logger.info(f"Zu≈ºycie quota: {quota_state['used']}/10000 ({quota_state['used']/100:.1f}%)")
            
            print("‚úÖ Codzienne zadanie raportowania zako≈Ñczone")
            logger.info("Codzienne zadanie raportowania zako≈Ñczone")
            
        except Exception as e:
            print(f"‚ùå B≈ÇƒÖd podczas wykonywania codziennego zadania: {e}")
            logger.error(f"B≈ÇƒÖd podczas wykonywania codziennego zadania: {e}")
    
    async def daily_ranking_analysis_task(self):
        """
        Codzienne zadanie analizy rankingowej o 1:30.
        Aktualizuje rankingi top 10 dla wszystkich kategorii.
        """
        try:
            logger.info("Rozpoczynam codziennƒÖ analizƒô rankingowƒÖ...")
            
            # Import ranking managera
            from app.trend.services.ranking_manager import ranking_manager
            
            # Pobierz wszystkie kategorie
            categories = self.state_manager.get_channels().keys()
            
            for category in categories:
                try:
                    logger.info(f"Analizujƒô ranking dla kategorii: {category}")
                    
                    # Znajd≈∫ najnowszy plik CSV dla tej kategorii
                    reports_dir = settings.reports_path
                    pattern = f"report_{category.upper()}_*.csv"
                    csv_files = list(reports_dir.glob(pattern))
                    
                    if not csv_files:
                        logger.warning(f"Nie znaleziono plik√≥w CSV dla kategorii {category}")
                        continue
                    
                    # We≈∫ najnowszy plik
                    latest_csv = sorted(csv_files)[-1]
                    logger.info(f"U≈ºywam pliku CSV: {latest_csv}")
                    
                    # Sprawd≈∫ czy to dzisiejszy raport (z 1:00)
                    try:
                        # Bezpieczniejsze parsowanie daty z nazwy pliku
                        filename = latest_csv.name
                        if '_' in filename:
                            csv_date = filename.split('_')[-1].replace('.csv', '')
                        else:
                            csv_date = latest_csv.stem
                        
                        today = datetime.now().strftime('%Y-%m-%d')
                        
                        if csv_date != today:
                            logger.warning(f"Ostatni raport dla {category} nie jest z dzisiaj: {csv_date} vs {today}")
                            continue
                    except Exception as e:
                        logger.warning(f"B≈ÇƒÖd podczas parsowania daty z nazwy pliku {latest_csv}: {e}")
                        # Kontynuuj mimo b≈Çƒôdu parsowania daty
                        pass
                    
                    # Wczytaj dane z CSV
                    df = pd.read_csv(latest_csv)
                    
                    # Konwertuj DataFrame na listƒô s≈Çownik√≥w
                    videos = df.to_dict('records')
                    
                    # Aktualizuj ranking
                    ranking = ranking_manager.update_ranking(category, videos)
                    
                    logger.info(f"Zaktualizowano ranking dla {category}: {len(ranking['shorts'])} shorts, {len(ranking['longform'])} longform")
                    
                except Exception as e:
                    logger.error(f"B≈ÇƒÖd podczas analizy rankingu dla kategorii {category}: {e}")
                    continue
            
            logger.info("Codzienna analiza rankingowa zako≈Ñczona")
            
        except Exception as e:
            logger.error(f"B≈ÇƒÖd podczas wykonywania codziennej analizy rankingowej: {e}")
    
    def add_channel(self, channel_data: Dict, category: str = "general"):
        """Dodaje kana≈Ç do monitorowania"""
        return self.state_manager.add_channel(channel_data, category)
    
    def remove_channel(self, channel_id: str, category: str = "general"):
        """Usuwa kana≈Ç z monitorowania"""
        return self.state_manager.remove_channel(channel_id, category)
    
    def get_channels(self) -> Dict[str, List[Dict]]:
        """Zwraca listƒô wszystkich kana≈Ç√≥w"""
        return self.state_manager.get_channels()
    
    def get_status(self) -> Dict:
        """Zwraca status schedulera"""
        channels = self.state_manager.get_channels()
        return {
            'running': self.scheduler.running,
            'jobs': len(self.scheduler.get_jobs()),
            'channels_count': sum(len(channels) for channels in channels.values()),
            'categories': list(channels.keys()),
            'next_run': self.scheduler.get_job('daily_report').next_run_time.isoformat() if self.scheduler.get_job('daily_report') else None
        }
    
    async def add_channel(self, channel_url: str, category: str = "general"):
        """Dodaje kana≈Ç do monitorowania"""
        try:
            # Pobierz informacje o kanale
            channel_info = await self.youtube_client.get_channel_info(channel_url)
            
            # Dodaj do state manager
            self.state_manager.add_channel(channel_info, category)
            
            logger.info(f"Dodano kana≈Ç: {channel_info['title']} do kategorii {category}")
            return channel_info
                
        except Exception as e:
            logger.error(f"B≈ÇƒÖd podczas dodawania kana≈Çu: {e}")
            raise
    
    async def get_channel_videos(self, channel_id: str, days_back: int = 7):
        """Pobiera filmy z kana≈Çu"""
        return await self.youtube_client.get_channel_videos(channel_id, days_back)
    
    def get_quota_usage(self) -> Dict:
        """Zwraca informacje o zu≈ºyciu quota"""
        return self.youtube_client.get_quota_usage()
    
    def get_cache_stats(self) -> Dict:
        """Zwraca statystyki cache"""
        return self.youtube_client.get_cache_stats()
    
    def cleanup_cache(self) -> int:
        """Czy≈õci przestarza≈Çy cache"""
        return self.youtube_client.cleanup_cache()

    def add_category(self, category_name: str) -> Dict:
        """Dodaje nowƒÖ kategoriƒô"""
        return self.state_manager.add_category(category_name)

    def remove_category(self, category_name: str, force: bool = False) -> Dict:
        """Usuwa kategoriƒô"""
        return self.state_manager.remove_category(category_name, force)

    def get_categories(self) -> List[Dict]:
        """Zwraca listƒô kategorii"""
        return self.state_manager.get_categories() 